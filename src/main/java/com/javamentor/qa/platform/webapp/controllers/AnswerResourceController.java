package com.javamentor.qa.platform.webapp.controllers;import com.javamentor.qa.platform.models.dto.AnswerDto;import com.javamentor.qa.platform.models.entity.question.answer.Answer;import com.javamentor.qa.platform.models.util.action.OnCreate;import com.javamentor.qa.platform.models.util.action.OnUpdate;import com.javamentor.qa.platform.service.abstracts.dto.AnswerDtoService;import com.javamentor.qa.platform.service.abstracts.model.AnswerService;import com.javamentor.qa.platform.webapp.converter.AnswerConverter;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiResponse;import io.swagger.annotations.ApiResponses;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.*;import javax.validation.Valid;import javax.validation.constraints.NotNull;import java.time.LocalDateTime;import java.util.List;import java.util.Map;@Validated@RestController@RequestMapping(value = "/api/user/question/{questionId}/answer", produces = "application/json")@Api(value = "AnswerApi", description = "Операции с ответами (создание, изменение, получение списка, получение ответов по ID вопроса)")public class AnswerResourceController {    private final AnswerConverter answerConverter;    private final AnswerService answerService;    private final AnswerDtoService answerDtoService;    private final Logger logger = LoggerFactory.getLogger(this.getClass());    public AnswerResourceController(AnswerConverter answerConverter, AnswerService answerService, AnswerDtoService answerDtoService) {        this.answerConverter = answerConverter;        this.answerService = answerService;        this.answerDtoService = answerDtoService;    }    @ApiOperation(value = "Получение ответов по ID вопроса с сортировкой по недавно добавленным/измененным")    @ApiResponses(value = {            @ApiResponse(code = 200, message = "Ответы получены")})    @GetMapping    public ResponseEntity<List<AnswerDto>> getAnswersDtoSortNew(@PathVariable @NotNull Long questionId) {        return ResponseEntity.ok(answerDtoService.getAnswersDtoByQuestionIdSortNew(questionId));    }    @ApiOperation(value = "Получение ответов по ID вопроса с сортировкой по счетчику полезности")    @ApiResponses(value = {            @ApiResponse(code = 200, message = "Ответы получены")})    @GetMapping("/sort/count")    public ResponseEntity<List<AnswerDto>> getAnswersDtoSortCount(@PathVariable @NotNull Long questionId) {        return ResponseEntity.ok(answerDtoService.getAnswersDtoByQuestionIdSortCount(questionId));    }    @ApiOperation(value = "Получение ответов по ID вопроса с сортировкой по дате создания")    @ApiResponses(value = {            @ApiResponse(code = 200, message = "Ответы получены")})    @GetMapping("/sort/date")    public ResponseEntity<List<AnswerDto>> getAnswersDtoSortDate(@PathVariable @NotNull Long questionId) {        return ResponseEntity.ok(answerDtoService.getAnswersDtoByQuestionIdSortDate(questionId));    }    @ApiOperation(value = "Добавление ответа по ID вопроса")    @ApiResponses(value = {            @ApiResponse(code = 200, message = "Ответ добавлен"),            @ApiResponse(code = 400, message = "ID вопроса в url и в dto не совпадают")    })    @Validated(OnCreate.class)    @PostMapping    public ResponseEntity<AnswerDto> addAnswer(@RequestBody @Valid AnswerDto answerDTO,                                               @PathVariable @NotNull Long questionId) {        if (questionId.equals(answerDTO.getQuestionId())) {            Answer answer = answerConverter.dtoToAnswer(answerDTO);            answerService.persist(answer);            logger.info(String.format("Ответ к вопросу с ID: %s добавлен в базу данных", answerDTO.getQuestionId()));            return ResponseEntity.status(HttpStatus.CREATED).body(answerDTO);        } else {            logger.error(String.format("Ответ к вопросу с ID: %s не добавлен в базу данных (в url ID вопроса: %s)",                    answerDTO.getQuestionId(), questionId));            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(answerDTO);        }    }    @ApiOperation(value = "Изменение текста ответа по ID вопроса и ID ответа. (ID != null)")    @ApiResponses(value = {            @ApiResponse(code = 200, message = "Ответ изменен"),            @ApiResponse(code = 400, message = "ID вопроса или ответа в url и в dto не совпадают")})    @Validated(OnUpdate.class)    @PatchMapping("/body/{answerId}")    public ResponseEntity<?> updateAnswerBody(@RequestBody @Valid AnswerDto answerDto,                                              @PathVariable @NotNull Long answerId,                                              @PathVariable @NotNull Long questionId) {        if (questionId.equals(answerDto.getQuestionId()) && answerId.equals(answerDto.getId())) {//            if (answerDto.getIsHelpful()) {//отдельная апи//                Answer answer = answerService.getByKey(answerDto.getId());//                if (answer.getIsHelpful()) {//                    answerDto.setDateAcceptTime(answer.getDateAcceptTime());//                } else {//                    answerService.resetIsHelpful(questionId);//отдельная апи//                    answerDto.setDateAcceptTime(LocalDateTime.now());//                }//                answer = answerConverter.dtoToAnswer(answerDto);//                answerService.update(answer);//                logger.info(String.format("Ответ с ID: %s к вопросу с ID: %s изменен", answerDto.getId(), answerDto.getQuestionId()));//                return ResponseEntity.ok(answerDto);//            } else answerDto.setDateAcceptTime(null);// в конвертере            Answer answer = answerConverter.dtoToAnswer(answerDto);            answerService.update(answer);//один update            logger.info(String.format("Ответ с ID: %s к вопросу с ID: %s изменен", answerDto.getId(), answerDto.getQuestionId()));            return ResponseEntity.ok(answerDto);        } else {            logger.error(String.format("Ответ с ID: %s к вопросу с ID: %s не изменен (в url ID ответа: %s, ID вопроса: %s)",                    answerDto.getId(), answerDto.getQuestionId(), answerId, questionId));            return ResponseEntity.badRequest().body(String.format("Ответ с ID: %s к вопросу с ID: %s не изменен (в url ID ответа: %s, ID вопроса: %s)",                    answerDto.getId(), answerDto.getQuestionId(), answerId, questionId));        }    }    @ApiOperation(value = "Изменение счетчика ответа по ID вопроса и ID ответа. (ID != null)")    @ApiResponses(value = {            @ApiResponse(code = 200, message = "Счетчик ответа изменен"),            @ApiResponse(code = 400, message = "ID вопроса или ответа в url и в dto не совпадают")})    @Validated(OnUpdate.class)    @PatchMapping("/count/{answerId}")    public ResponseEntity<?> updateAnswerCount(@RequestBody @Valid AnswerDto answerDto,                                               @PathVariable @NotNull Long answerId,                                               @PathVariable @NotNull Long questionId) {        if (questionId.equals(answerDto.getQuestionId()) && answerId.equals(answerDto.getId())) {            answerService.getByKey(answerId);        } else {            logger.error(String.format("Ответ с ID: %s к вопросу с ID: %s не изменен (в url ID ответа: %s, ID вопроса: %s)",                    answerDto.getId(), answerDto.getQuestionId(), answerId, questionId));            return ResponseEntity.badRequest().body(String.format("Ответ с ID: %s к вопросу с ID: %s не изменен (в url ID ответа: %s, ID вопроса: %s)",                    answerDto.getId(), answerDto.getQuestionId(), answerId, questionId));        }    }    @GetMapping("/{answerId}")//todo test    public ResponseEntity<?> isHelpfulAnswer(@PathVariable Long answerId) {        Answer answer = answerService.getByKey(answerId);        if (answer != null) {            return ResponseEntity.ok(answer.getIsHelpful());        } else {            return ResponseEntity.badRequest().body(String.format("Answer id:%s not found in DB", answerId));        }    }    @ApiOperation(value = "Удаление ответа по ID вопроса и ID ответа")    @ApiResponses(value = {@ApiResponse(code = 200, message = "Ответ удален")})    @DeleteMapping("/{answerId}")    public ResponseEntity<String> deleteAnswer(@PathVariable @NotNull Long answerId, @PathVariable @NotNull Long questionId) {        answerService.deleteByFlagById(answerId);        logger.info(String.format("Ответ с ID: %s удален", answerId));        return ResponseEntity.ok().build();    }}